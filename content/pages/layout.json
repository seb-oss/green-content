{
  "title": "Declarative layout",
  "slug": "primitives/declarative-layout",
  "summary": "A micro-frontend optimized layout system for responsive layouts without utility classes. The relationships between elements rely on the set rules for spacing, grids, and sizing, ensuring consistency throughout.",
  "parent": "primitives",
  "layout": "editorial",
  "sections": [
    {
      "max-width": false,
      "cols": "1",
      "columns": [
        {
          "type": "snippet",
          "plain": false,
          "replay": false,
          "Snippet": "declarative-layout-hero"
        }
      ]
    },
    {
      "max-width": true,
      "cols": "1",
      "columns": [
        {
          "type": "paragraph",
          "size": "body-l",
          "text": "Declarative programming is a non-imperative style of programming in which programs describe their desired results without explicitly listing commands or steps that must be performed."
        },
        {
          "type": "rich-text",
          "content": "In the context of declarative layout, \"declarative\" means that the visual aspects of the layout are declared directly in the markup. Declarative layout helps developers \"code at the speed of thought\", by letting them declare layouts without having to think up names for CSS classes or constantly look up variable names. It’s also built in a way that utilizes the encapsulation properties of shadow DOM so the risk of styling conflicts between MFEs is eliminated.\n\nDeclarative layout can be though of as a minimal CSS framework, just not using CSS directly. It can be minimal, since it's only intended to be used with Green components, and the components themselves already have styles encapsulated. Declarative layout is not a CSS framework for building components, it's one for putting existing components together in a layout. It's the glue that turns a collection of individual components into a complete and consistent app design."
        },
        {
          "type": "rich-text",
          "title": "How it works",
          "tag": "H2",
          "content": "In the Core library, components can have special properties for declaring styles. These are called **\"Style Expression Properties\"**, sometimes abbreviated as **\"SEPs\"**. A style expression property typically corresponds to a CSS-property, such as `padding` or `margin`."
        },
        {
          "type": "code",
          "code": "<gds-div margin=\"m\"> … </gds-div>"
        },
        {
          "type": "rich-text",
          "content": "The style expression syntax accepts values to control the associated property and also supports simplified forms of media queries and pseudo selectors."
        },
        {
          "type": "code",
          "code": "<gds-div margin=\"m; m { l }; hover: l\"> … </gds-div>\n"
        },
        {
          "type": "rich-text",
          "content": "When the component is rendered, the style expression properties are compiled into regular CSS which is then injected into the shadow DOM of the component.\n\nSEPs can be assigned using either [properties](https://developer.mozilla.org/en-US/docs/Glossary/Property/JavaScript) or [attributes.](https://developer.mozilla.org/en-US/docs/Glossary/Attribute)"
        }
      ]
    },
    {
      "title": "Style expression syntax",
      "tag": "H2",
      "section-content": "The style expression syntax is designed to express a set of values for a single CSS property. The name of the property is generally the same as the corresponding CSS property and typically the values will be specified using a design token name. In some cases arbitrary CSS values are also accepted. The syntax also enables using different values based on viewport and/or pseudo selector.\n\nLet’s look at some examples to clarify things.\n\n#### Basic expressions\n\n`margin=\"m\"`\n\nA single token is the most basic form of style expression. Here we set the margin property to medium. The value is taken from a token in the spacing collection. In this example it would resolve to `--gds-sys-space-m`.\n\n`margin=\"0 m 0 0\"`\n\nStyle expression values typically follow the same structure as the corresponding CSS property. Since \\`margin\\` is as short-hand property in CSS, it accepts values for all for sides: Top, right, left, and bottom. In the example above, we're setting only the right margin.\n\n#### Viewport conditions\n\nAs we have already touched upon, a style expression can express a set of values. Values are separated by semi colon:\n\n`margin=\"m; s { l }\"`\n\nHere we add another value with a viewport condition. We’re saying **\"set margin to** `m`**, but above** `s` **viewports, set it to** `l`**\"**.\n\nViewport conditions have the format of \\`condition { value }\\` and any number of them can be added to a style expression.\n\nViewport conditions can be narrowed down to ranges and use custom values if needed.\n\n`margin=\"xs; >s,<xl { m }\"`\n\nHere we are saying **\"use** `xs` **margin, but above** `s` **viewports and below** `xl` **viewports, use** `m` **margin\"**\n\nViewport values can also be regular CSS units:\n\n`margin=\"xs; >800px,<1000px { m }\"`\n\n#### Pseudo selectors\n\nPseudo selectors have the format of \\`selector: value\\` and can be used to apply values only on certain states, like hover, focus, etc.\n\n`margin=\"xs; hover: l\"`\n\nHere we say **\"set margin to** `xs`**, but use** `l` **on hover\"**\n\nPseudo selectors can also be combined with viewport conditions, in which case the selector statement is used as a value within the condition body:\n\n`margin=\"xs; hover:l; s { s; hover: xl }\"`\n\n#### Colours\n\nSetting color properties, like `color`, `background`, `border-color`, and so on, works the same way as spacings, but there are some differences when it comes to variable resolution to be aware of.\n\nThe color system in GDS, which you can read more about here, is organized into collections of backgrounds, content, border, and state colours. Depending on which property is used, a variable will be resolved from the appropriate collection. For example, `background` will resolve to background colours, and `color` will resolve to content colours.\n\nBackgrounds have an additional quirk to be aware of: **Levels**.\n\nThe background colours are divided into three levels, and the correct level will depend on the type of component. In general, document backgrounds are level 1, containers, such as div, card, and grid are level 2, and interactive components, such as buttons and input fields, are level three.\n\nMost of the time this is automatically handled, but if you need to override the level, you can use the `level` property. For example, to make a card use level 3 backgrounds, you can set it up like this:\n\n```html\n<gds-card level=\"3\" background=\"neutral-01\">…</gds-card>\n```\n\nThis will resolve to the `—gds-sys-color-l3-neutral-01` token.\n\n#### Token mapping table\n\nTokens are mapped to SEPs roughly according to this table.\n\n| Property group | Token collection |\n| --- | --- |\n| Spacing properties, like `margin`, `padding`, `gap`, `border-width`, etc | `gds.sys.space.*` |\n| `background` | `gds.sys.color.l[x].*` |\n| `color` | `gds.sys.color.content.*` |\n| `border-color` | `gds.sys.color.border.*` |\n\n### Declarative layout components\n\nThe corner stone of declarative layout is the `<gds-div>`. This is a generic container element which supports all available style expressions. In declarative layout, you use `<gds-div>` and style expressions in much the same way you would use `<div>` and CSS classes in regular HTML/CSS land.\n\nThen, on top of `<gds-div>` there are a few more specialized components: `<gds-flex>`, `<gds-grid>` and `<gds-card>`\n\nThese extends `<gds-div>` and sets some other default values, and in some cases additional helper properties.\n\n*   **Flex** `<gds-flex>`  \n    This is a `<gds-div>` with `display=\"flex\"` by default.\n    \n*   **Grid** `<gds-grid>`  \n    This is a `<gds-div>` with `display=\"grid\"` by default, as well as some helper properties specific to grids.\n    \n*   **Card** `<gds-card>`  \n    This is a `<gds-div>` with `background`, `padding`, `border-radius` defaults, as well as a `variant` helper property to get standardized card designs.\n    \n\n### SEP modularity\n\nStyle expression properties are not limited to these main declarative layout components however. Instead, SEPs are a modular feature of the Core component library, making it possible to include them on any component. You will find these kinds of properties on all the places where it makes sense throughout the library. For example, you can set `width` as a style expression on `<gds-button>`.\n\nIn the API-tables in Storybook, you can find all the style expression properties for a component under the collapsed \"Declarative Layout / Style Expression Properties\" section.",
      "max-width": true
    }
  ]
}